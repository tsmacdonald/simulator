Trigger:
Triggers will be a bit more complicated. First of all, Triggers need a priority to determine which Trigger takes precedence for the "turn" in the simulation if two triggers' conditions are met. Triggers will make comparisons on the parent Agent and an (implied) other Agent. Note that the other Agent need not be applicable for something like moveRandom(). If the trigger conditions are met (all comparisons check out), the trigger will execute. Each trigger may have multiple conditions. Thus, a Trigger will need an BinaryTree of conditions. Consider the following boolean expression:
(a && b) || (c || d). It would be difficult to evaluate this using an ArrayList, so the BinaryTree works better:

        ||
       /  \
    &&      ||
   /  \    /  \
  a    b  c    d

This still has a problem with complex expressions like:
(a + b > c) && (d * e == f)

This gets complicated. Think back to our calculator from Programming II. The nodes of that tree only either (a) took nothing and returned an int (leaf) or (b) took a left and right and returned an int. In this case, though, we have (a) leaves, which are the primitive values, (b) binary operators (+, -, *, /) which take two primitives and return a primitive, (c) comparison operators (==, !=, >, <, >=, <=) which take two primitives and return a boolean, and (d) logical operators (&& || !) which take one or two booleans and return a boolean.

Therefore, we need a tree of BooleanExpressions. with method evaluate().
BooleanExpression classes:
-BooleanExpressionOperator (&& || !) (subclass)
--with instance variables leftBooleanExpression and rightBooleanExpression
-BooleanExpression (true, false)
--with instance variable value

To handle comparison operators, BooleanExpession needs another subclass:
-BooleanExpressionComparison (==, !=, >, <, >=, <=)
--with instance variables leftPrimitiveExpression and rightPrimitiveExpression

to handle binary operators, a class PrimitiveExpression and subclass PrimitiveExpressionOperator with method evaluate():
-PrimitiveExpression (literal value)
--with instance variable value
-PrimitiveExpressionOperator(+, -, *, /)
--with instance variables PrimitiveExpressionLeft and PrimitiveExpressionRight

The above is essentially a tree of trees of trees. That handles the trigger conditions. Now, there needs to be an ArrayList of Consequences/Events/Outcomes. We've already brainstormed possible things: die(), clone(), setField(), setFieldOther(), moveRandom().

With all that being said, here's an example we could concoct and parse with this setup. NOTE THAT IF WE PARSE IT CORRECTLY THE USER CAN SPECIFY THIS WHOLE LOGICAL EXPRESSION:
consider the trigger's owner to be "rabbit."
if (wolf.xPos == rabbit.xPos && wolf.yPos == rabbit.yPos) {
  setFieldOther("weight", wolf.weight + 5);
  die();
}